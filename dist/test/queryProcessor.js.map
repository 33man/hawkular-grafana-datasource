{"version":3,"sources":["../../src/queryProcessor.js"],"names":[],"mappings":"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","file":"queryProcessor.js","sourcesContent":["export class QueryProcessor {\n\n  constructor(q, backendSrv, variables, url, baseHeaders) {\n    this.q = q;\n    this.backendSrv = backendSrv;\n    this.variables = variables;\n    this.url = url;\n    this.baseHeaders = baseHeaders;\n  }\n\n  run(target, options) {\n    if (target.queryBy === 'ids') {\n      let metricIds = this.variables.resolve(target.target, options);\n      return this.rawQuery(target, options.range, metricIds)\n        .then(response => this.processRawResponse(target, response));\n    } else {\n      if (target.tags.length === 0) {\n        return this.q.when([]);\n      }\n      let strTags = this.hawkularFormatTags(target.tags, options);\n      return this.rawQueryByTags(target, options.range, strTags)\n        .then(response => this.processRawResponse(target, response));\n    }\n  }\n\n  hawkularFormatTags(tags, options) {\n    return tags.map(tag => {\n      var value;\n      if (tag.value === ' *') {\n        // '*' character get a special treatment in grafana so we had to use ' *' instead\n        value = '*';\n      } else {\n        value = this.variables.resolve(tag.value, options).join('|');\n      }\n      return tag.name + ':' + value;\n    }).join(',');\n  }\n\n  rawQuery(target, range, metricIds) {\n    let uri = [\n      target.type + 's',            // gauges or counters\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    let url = this.url + '/' + uri.join('/');\n\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: {\n        ids: metricIds,\n        start: range.from.valueOf(),\n        end: range.to.valueOf()\n      },\n      method: 'POST',\n      headers: this.baseHeaders\n    }).then(response => {\n      return response.status == 200 ? response.data : [];\n    });\n  }\n\n  rawQueryByTags(target, range, tags) {\n    let uri = [\n      target.type + 's',            // gauges or counters\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    let url = this.url + '/' + uri.join('/');\n\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: {\n        tags: tags,\n        start: range.from.valueOf(),\n        end: range.to.valueOf()\n      },\n      method: 'POST',\n      headers: this.baseHeaders\n    }).then(response => {\n      return response.status == 200 ? response.data : [];\n    });\n  }\n\n  processRawResponse(target, response) {\n    var datapoints = timeSerie => timeSerie.data.map(point => [point.value, point.timestamp]);\n    return response.map(timeSerie => {\n      return {\n        refId: target.refId,\n        target: timeSerie.id,\n        datapoints: datapoints(timeSerie)\n      };\n    });\n  }\n}\n"]}